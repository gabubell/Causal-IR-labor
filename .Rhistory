)
cols_to_keep_existing <- intersect(cols_to_keep, names(raw_dt))
prepared_data_final <- raw_dt[, ..cols_to_keep_existing]
if (!dir.exists(OUTPUT_DIR)) {
dir.create(OUTPUT_DIR, recursive = TRUE)
}
saveRDS(prepared_data_final, file = PREPARED_DATA_PATH)
PREPARED_DATA_PATH
# --- 0. Limpeza do Ambiente e Carregamento de Pacotes ---
rm(list = ls()); gc()
library(dplyr)
library(lubridate)
library(data.table)
# Carrega as configurações do projeto
source("00_config.R")
# --- 1. Carregamento dos Dados Preparados ---
cat("ETAPA 1: Carregando dados preparados de:", PREPARED_DATA_PATH, "\n")
if (!file.exists(PREPARED_DATA_PATH)) stop("Arquivo de dados preparados não encontrado. Rode o script 01 primeiro.")
prepared_dt <- readRDS(PREPARED_DATA_PATH)
setDT(prepared_dt)
# ===========================================================================
# CRIAÇÃO DA FLAG CUMULATIVA DE PAGAMENTO CONSECUTIVO DE IR
# ===========================================================================
cat("Criando flag CUMULATIVA de pagamento consecutivo de Imposto de Renda...\n")
setorder(prepared_dt, cpf, data_referencia_mes)
prepared_dt[, trigger_event := fifelse(paid_ir > 0 & shift(paid_ir, type = "lag") > 0, 1, 0, na = 0), by = .(cpf)]
prepared_dt[, has_paid_ir_consecutive := as.integer(cumsum(trigger_event) > 0), by = .(cpf)]
prepared_dt[, trigger_event := NULL]
cat("  - Variável cumulativa 'has_paid_ir_consecutive' criada com sucesso.\n")
# ===========================================================================
# FILTRO POR TIPO DE ADMISSÃO
# ===========================================================================
if (exists("FILTER_BY_ADM_TYPE") && FILTER_BY_ADM_TYPE == TRUE) {
if (!"tipoadm" %in% names(prepared_dt)) stop("ERRO: A coluna 'tipoadm' não foi encontrada.")
cpfs_with_standard_contract <- unique(prepared_dt[year == BASE_YEAR & month == 12 & tipoadm == '1', cpf])
if (length(cpfs_with_standard_contract) == 0) warning("AVISO: Nenhum CPF encontrado com tipoadm == '1'. O filtro não removerá ninguém.")
n_before <- uniqueN(prepared_dt$cpf)
prepared_dt <- prepared_dt[cpf %in% cpfs_with_standard_contract]
n_after <- uniqueN(prepared_dt$cpf)
cat("  - CPFs antes do filtro 'tipoadm':", n_before, "\n")
cat("  - CPFs encontrados com vínculo padrão:", length(cpfs_with_standard_contract), "\n")
cat("  - CPFs restantes após o filtro:", n_after, "\n")
rm(cpfs_with_standard_contract, n_before, n_after)
gc()
} else {
cat("ETAPA 1.5: Filtro por tipo de admissão (tipoadm) está DESLIGADO.\n")
}
# =================================================================================
# --- ETAPA 2: FILTRAGEM POR HISTÓRICO DE PAGAMENTO DE IR ---
# =================================================================================
cat("ETAPA 2: Aplicando filtro por histórico de pagamento de IR (Modo:", IR_FILTER_MODE, ")...\n")
pre_event_data <- prepared_dt[year < BASE_YEAR + 1]
if (IR_FILTER_MODE == 'nunca_pagou') {
# --- MODO (a): Mantém quem NUNCA pagou IR antes de 2016 ---
cpfs_to_remove <- unique(pre_event_data[paid_ir == 1, cpf])
cat("  - Modo 'nunca_pagou': Removendo", length(cpfs_to_remove), "CPFs que já pagaram IR antes de 2016.\n")
filtered_dt <- prepared_dt[!(cpf %in% cpfs_to_remove)]
} else if (IR_FILTER_MODE == 'pagou_pouco') {
# 1. Calcula quantas vezes cada CPF pagou IR no período pré-evento
ir_payment_counts <- pre_event_data[paid_ir == 1, .N, by = cpf]
setnames(ir_payment_counts, "N", "ir_payments_count")
# Pega todos os CPFs do período pré-evento para garantir que quem pagou 0 vezes seja incluído
all_cpfs_pre_event <- data.table(cpf = unique(pre_event_data$cpf))
# Junta a contagem de pagamentos. Quem não pagou terá NA.
ir_payment_counts <- merge(all_cpfs_pre_event, ir_payment_counts, by = "cpf", all.x = TRUE)
# Substitui NA por 0 (quem não está na contagem original é porque pagou 0 vezes)
ir_payment_counts[is.na(ir_payments_count), ir_payments_count := 0]
# 2. Identifica os CPFs que devem ser MANTIDOS na amostra
cpfs_to_keep <- ir_payment_counts[
ir_payments_count == IR_FILTER_MAX_PAYMENTS,
cpf
]
cat("  - Encontrados", length(cpfs_to_keep), "CPFs que atendem filtro de pagou_pouco.\n")
# ================================================================================
# 3. Filtra a base principal, mantendo APENAS quem está na lista
filtered_dt <- prepared_dt[cpf %in% cpfs_to_keep]
} else if (IR_FILTER_MODE == 'sem_filtro') {
# --- MODO (c): Sem filtro por histórico de IR ---
cat("  - Modo 'sem_filtro': Nenhum filtro por histórico de IR será aplicado.\n")
filtered_dt <- prepared_dt
} else {
stop("ERRO: 'IR_FILTER_MODE' desconhecido: '", IR_FILTER_MODE, "'. Verifique 00_config.R.")
}
rm(pre_event_data)
if (exists("cpfs_to_remove")) rm(cpfs_to_remove)
if (exists("ir_payment_counts")) rm(ir_payment_counts)
if (exists("cpfs_to_keep")) rm(cpfs_to_keep)
gc()
cat("  - CPFs restantes na amostra após filtro de IR:", uniqueN(filtered_dt$cpf), "\n")
# --- 3. Definição dos Grupos de Tratamento e Controle ---
cat("ETAPA 3: Definindo grupos de T/C com base na renda do VÍNCULO PRINCIPAL em Dezembro de", BASE_YEAR, "...\n")
cat("   - Usando a coluna '", SALARY_COL_FOR_GROUPS, "' para definição dos grupos.\n", sep="")
base_month_data <- filtered_dt[year == BASE_YEAR & month == 12 & !is.na(id_vinculo_original)]
setorder(base_month_data, cpf, -salcontr)
principal_jobs_dt <- unique(base_month_data, by = "cpf")[, .(cpf, id_vinculo_original)]
base_salaries_dt <- filtered_dt[principal_jobs_dt, on = .(cpf, id_vinculo_original), nomatch = 0]
base_salaries_dt <- base_salaries_dt[year == BASE_YEAR & month == 12]
base_salaries_dt[, base_salary_metric := get(SALARY_COL_FOR_GROUPS)]
base_salaries_dt <- base_salaries_dt[!is.na(base_salary_metric), .(cpf, base_salary_metric)]
treatment_upper_thresh <- IR_LIMIT_BASE_YEAR
treatment_lower_thresh <- IR_LIMIT_BASE_YEAR * (1 - TREATMENT_PERCENT_BELOW_LIMIT)
control_upper_thresh <- treatment_lower_thresh * (1 - CONTROL_GAP_PERCENT)
control_lower_thresh <- control_upper_thresh - (treatment_lower_thresh * CONTROL_WIDTH_PERCENT)
cat("  - Limiar de isenção:", IR_LIMIT_BASE_YEAR, "\n")
cat("  - Faixa de Tratamento: [", round(treatment_lower_thresh, 2), ",", round(treatment_upper_thresh, 2), ")\n")
cat("  - Faixa de Controle:   [", round(control_lower_thresh, 2), ",", round(control_upper_thresh, 2), ")\n")
base_salaries_dt[, assigned_group := case_when(
base_salary_metric >= treatment_lower_thresh & base_salary_metric < treatment_upper_thresh ~ "Treatment",
base_salary_metric >= control_lower_thresh & base_salary_metric < control_upper_thresh ~ "Control",
TRUE ~ "Other"
)]
initial_groups_dt <- base_salaries_dt[assigned_group %in% c("Treatment", "Control")]
n_treatment <- nrow(initial_groups_dt[assigned_group == "Treatment"])
n_control <- nrow(initial_groups_dt[assigned_group == "Control"])
cat("  -", n_treatment, "indivíduos definidos como Tratamento.\n")
cat("  -", n_control, "indivíduos definidos como Controle.\n")
if (n_treatment == 0 || n_control == 0) {
stop("Um dos grupos (Tratamento ou Controle) ficou vazio. Verifique os parâmetros de definição de grupo.")
}
# --- 4. Preparação e Salvamento do Dataset Final ---
cat("ETAPA 4: Preparando e salvando o dataset final para pareamento...\n")
final_data_for_matching <- filtered_dt[cpf %in% initial_groups_dt$cpf]
final_data_for_matching[initial_groups_dt, on = "cpf", assigned_group := i.assigned_group]
# --- ETAPA 5: Cálculo Proporcional das Horas Trabalhadas ---
cat("ETAPA 5: Calculando horas proporcionais aos dias trabalhados no mês...\n")
final_data_for_matching[, `:=` (
dtadmissao = as.Date(dtadmissao),
data_desligamento_efetiva = as.Date(data_desligamento_efetiva)
)]
final_data_for_matching[, horas_ajustadas := {
inicio_mes <- floor_date(data_referencia_mes, "month")
fim_mes <- ceiling_date(data_referencia_mes, "month") - days(1)
data_inicio_efetiva <- pmax(dtadmissao, inicio_mes, na.rm = TRUE)
data_fim_efetiva <- pmin(data_desligamento_efetiva, fim_mes, na.rm = TRUE)
dias_trabalhados_no_mes <- as.numeric(data_fim_efetiva - data_inicio_efetiva) + 1
proporcao_mes <- dias_trabalhados_no_mes / as.numeric(days_in_month(data_referencia_mes))
horascontr * proporcao_mes
}, by = 1:nrow(final_data_for_matching)]
saveRDS(final_data_for_matching, file = FILTERED_DATA_PATH)
# --- 0. Limpeza, Pacotes e Configuração ---
rm(list = ls()); gc()
library(data.table)
library(MatchIt)
source("00_config.R")
# --- 1. Carregamento dos Dados ---
cat("ETAPA 1: Carregando dados filtrados...\n")
filtered_dt <- readRDS(FILTERED_DATA_PATH)
# =======================================================================================
# ETAPA 2: Preparação com Perfil Mensal de Empregos no Pareamento EXATO
# =======================================================================================
cat("ETAPA 2: Preparando base de dados para o pareamento (1 linha por CPF)...\n")
BASE_YEAR <- 2015
# --- 2a. Dados de Dezembro/2015: Vínculo Principal e Variáveis Escalares ---
cat("   - Agregando dados de Dez/2015 para variáveis escalares...\n")
dec_2015_dt <- filtered_dt[year == BASE_YEAR & month == 12]
base_vars_dt <- dec_2015_dt[order(cpf, -salario_vinculo_mes_bruto), .(
assigned_group = first(assigned_group), municipio = first(municipio),
cbo_5digits = first(cbo_5digits), cnae_secao = first(cnae_secao),
education_level_grouped = first(education_level_grouped), tempempr = as.numeric(first(tempempr)),
salcontr_total_2014 = first(salcontr_total_2014)
), by = cpf]
cat("      - Base com variáveis escalares criada para", nrow(base_vars_dt), "indivíduos.\n")
# --- 2b. Perfil Mensal Agregado para o Ano Inteiro de 2015 ---
cat("   - Criando perfil mensal agregado para todo o ano de 2015...\n")
monthly_agg_dt <- filtered_dt[year == BASE_YEAR, .(
total_relative_complement_salary = first(total_relative_complement_salary),
paid_ir_monthly = max(paid_ir, na.rm = TRUE),
num_jobs_monthly =  sum(!is.na(id_vinculo_original)),
total_hours_monthly = sum(horas_ajustadas, na.rm = TRUE)
), by = .(cpf, month)]
monthly_profile_wide <- dcast(
monthly_agg_dt,
cpf ~ month,
value.var = c("total_relative_complement_salary", "paid_ir_monthly", "num_jobs_monthly", "total_hours_monthly"),
fill = NA
)
salary_names <- paste0("var_sal_m", 1:12)
ir_names <- paste0("paid_ir_m", 1:12)
jobs_names <- paste0("jobs_m", 1:12)
hours_names <- paste0("hours_m", 1:12)
setnames(monthly_profile_wide, names(monthly_profile_wide)[-1], c(salary_names, ir_names, jobs_names, hours_names))
na_dummy_names <- paste0(salary_names, "_is_na")
monthly_profile_wide[, (na_dummy_names) := lapply(.SD, function(x) as.integer(is.na(x))), .SDcols = salary_names]
monthly_profile_wide[, (salary_names) := lapply(.SD, function(x) fcoalesce(x, 0)), .SDcols = salary_names]
monthly_profile_wide[, (ir_names) := lapply(.SD, function(x) fcoalesce(x, 0)), .SDcols = ir_names]
monthly_profile_wide[, (jobs_names) := lapply(.SD, function(x) fcoalesce(x, 0L)), .SDcols = jobs_names]
monthly_profile_wide[, (hours_names) := lapply(.SD, function(x) fcoalesce(x, 0)), .SDcols = hours_names]
cat("      - Perfil mensal agregado criado.\n")
# --- 2c. Junção Final e Definição das Variáveis para Pareamento ---
cat("   - Juntando bases e preparando para o pareamento...\n")
data_for_matching <- merge(base_vars_dt, monthly_profile_wide, by = "cpf", all.x = TRUE)
data_for_matching[, treatment_dummy := fifelse(assigned_group == "Treatment", 1, 0)]
# Variáveis para pareamento EXATO
exact_vars_final <- c(
PSM_EXACT_MATCH_VARS,
na_dummy_names,
jobs_names,
ir_names,
hours_names
)
# Variáveis para pareamento por DISTÂNCIA
nearest_vars_final <- c(
PSM_NEAREST_MATCH_VARS_SCALAR,
salary_names
)
# Limpeza de NAs
all_vars_to_check <- c(exact_vars_final, nearest_vars_final)
data_for_matching <- na.omit(data_for_matching, cols = all_vars_to_check)
cat("   - Base de pareamento final preparada com", nrow(data_for_matching), "indivíduos únicos.\n")
cat("   - Variáveis para pareamento EXATO:", paste(exact_vars_final, collapse=", "), "\n")
cat("   - Variáveis para DISTÂNCIA:", paste(nearest_vars_final, collapse=", "), "\n")
# --- 3. LÓGICA CONDICIONAL DE PAREAMENTO ---
cat("\nETAPA 3: Executando o modo de pareamento selecionado:", PSM_MODE, "\n")
if (PSM_MODE == "sem_psm") {
# MODO 1: SEM PAREAMENTO
cat("--- Nenhum pareamento será executado. Usando todos os indivíduos dos grupos T/C definidos.\n")
matched_cpfs <- data_for_matching$cpf
} else if (PSM_MODE == "psm_exato") {
# MODO 2: APENAS PAREAMENTO EXATO
cat("--- Executando apenas o pareamento EXATO...\n")
cat("  - Variáveis de pareamento exato:", paste(exact_vars_final, collapse=", "), "\n")
match_obj <- matchit(
formula = treatment_dummy ~ 1,
data = as.data.frame(data_for_matching),
method = "exact",
estimand = "ATT"
)
cat("  - Resumo do Pareamento Exato:\n")
print(summary(match_obj, un = FALSE))
matched_cpfs <- match.data(match_obj)$cpf
} else if (PSM_MODE == "psm_completo") {
# MODO 3: PAREAMENTO COMPLETO (EXATO + DISTÂNCIA)
cat("--- Executando o pareamento COMPLETO (Exato + Mahalanobis)...\n")
match_formula <- as.formula(paste("treatment_dummy ~", paste(nearest_vars_final, collapse = " + ")))
cat("  - Variáveis de pareamento exato:", paste(exact_vars_final, collapse=", "), "\n")
cat("  - Variáveis para distância:", paste(nearest_vars_final, collapse=", "), "\n")
match_obj <- matchit(
formula = match_formula,
data = as.data.frame(data_for_matching),
method = "nearest",
distance = "mahalanobis",
exact = exact_vars_final,
ratio = 1,
replace = FALSE,
estimand = "ATT"
)
cat("  - Resumo do Pareamento Completo:\n")
print(summary(match_obj, un = FALSE))
matched_cpfs <- match.data(match_obj)$cpf
} else {
stop("Modo de PSM '", PSM_MODE, "' não reconhecido. Verifique 00_config.R.")
}
# --- 4. Salvamento dos Resultados ---
cat("\nETAPA 4: Salvando os resultados...\n")
# --- 0. Limpeza, Pacotes e Configuração ---
rm(list = ls()); gc()
library(data.table)
library(MatchIt)
source("00_config.R")
# --- 1. Carregamento dos Dados ---
cat("ETAPA 1: Carregando dados filtrados...\n")
filtered_dt <- readRDS(FILTERED_DATA_PATH)
# =======================================================================================
# ETAPA 2: Preparação com Perfil Mensal de Empregos no Pareamento EXATO
# =======================================================================================
cat("ETAPA 2: Preparando base de dados para o pareamento (1 linha por CPF)...\n")
View(filtered_dt)
BASE_YEAR <- 2015
# --- 2a. Dados de Dezembro/2015: Vínculo Principal e Variáveis Escalares ---
cat("   - Agregando dados de Dez/2015 para variáveis escalares...\n")
dec_2015_dt <- filtered_dt[year == BASE_YEAR & month == 12]
base_vars_dt <- dec_2015_dt[order(cpf, -salario_vinculo_mes_bruto), .(
assigned_group = first(assigned_group), municipio = first(municipio),
cbo_5digits = first(cbo_5digits), cnae_secao = first(cnae_secao),
education_level_grouped = first(education_level_grouped), tempempr = as.numeric(first(tempempr)),
salcontr_total_2014 = first(salcontr_total_2014)
), by = cpf]
cat("      - Base com variáveis escalares criada para", nrow(base_vars_dt), "indivíduos.\n")
# --- 2b. Perfil Mensal Agregado para o Ano Inteiro de 2015 ---
cat("   - Criando perfil mensal agregado para todo o ano de 2015...\n")
monthly_agg_dt <- filtered_dt[year == BASE_YEAR, .(
total_relative_complement_salary = first(total_relative_complement_salary),
paid_ir_monthly = max(paid_ir, na.rm = TRUE),
num_jobs_monthly =  sum(!is.na(id_vinculo_original)),
total_hours_monthly = sum(horas_ajustadas, na.rm = TRUE)
), by = .(cpf, month)]
monthly_profile_wide <- dcast(
monthly_agg_dt,
cpf ~ month,
value.var = c("total_relative_complement_salary", "paid_ir_monthly", "num_jobs_monthly", "total_hours_monthly"),
fill = NA
)
salary_names <- paste0("var_sal_m", 1:12)
ir_names <- paste0("paid_ir_m", 1:12)
jobs_names <- paste0("jobs_m", 1:12)
hours_names <- paste0("hours_m", 1:12)
setnames(monthly_profile_wide, names(monthly_profile_wide)[-1], c(salary_names, ir_names, jobs_names, hours_names))
na_dummy_names <- paste0(salary_names, "_is_na")
monthly_profile_wide[, (na_dummy_names) := lapply(.SD, function(x) as.integer(is.na(x))), .SDcols = salary_names]
monthly_profile_wide[, (salary_names) := lapply(.SD, function(x) fcoalesce(x, 0)), .SDcols = salary_names]
monthly_profile_wide[, (ir_names) := lapply(.SD, function(x) fcoalesce(x, 0)), .SDcols = ir_names]
monthly_profile_wide[, (jobs_names) := lapply(.SD, function(x) fcoalesce(x, 0L)), .SDcols = jobs_names]
monthly_profile_wide[, (hours_names) := lapply(.SD, function(x) fcoalesce(x, 0)), .SDcols = hours_names]
cat("      - Perfil mensal agregado criado.\n")
# --- 2c. Junção Final e Definição das Variáveis para Pareamento ---
cat("   - Juntando bases e preparando para o pareamento...\n")
data_for_matching <- merge(base_vars_dt, monthly_profile_wide, by = "cpf", all.x = TRUE)
data_for_matching[, treatment_dummy := fifelse(assigned_group == "Treatment", 1, 0)]
# Variáveis para pareamento EXATO
exact_vars_final <- c(
PSM_EXACT_MATCH_VARS,
na_dummy_names,
jobs_names,
ir_names,
hours_names
)
# Variáveis para pareamento por DISTÂNCIA
nearest_vars_final <- c(
PSM_NEAREST_MATCH_VARS_SCALAR,
salary_names
)
# Limpeza de NAs
all_vars_to_check <- c(exact_vars_final, nearest_vars_final)
data_for_matching <- na.omit(data_for_matching, cols = all_vars_to_check)
cat("   - Base de pareamento final preparada com", nrow(data_for_matching), "indivíduos únicos.\n")
cat("   - Variáveis para pareamento EXATO:", paste(exact_vars_final, collapse=", "), "\n")
cat("   - Variáveis para DISTÂNCIA:", paste(nearest_vars_final, collapse=", "), "\n")
# --- 3. LÓGICA CONDICIONAL DE PAREAMENTO ---
cat("\nETAPA 3: Executando o modo de pareamento selecionado:", PSM_MODE, "\n")
if (PSM_MODE == "sem_psm") {
# MODO 1: SEM PAREAMENTO
cat("--- Nenhum pareamento será executado. Usando todos os indivíduos dos grupos T/C definidos.\n")
matched_cpfs <- data_for_matching$cpf
} else if (PSM_MODE == "psm_exato") {
# MODO 2: APENAS PAREAMENTO EXATO
cat("--- Executando apenas o pareamento EXATO...\n")
cat("  - Variáveis de pareamento exato:", paste(exact_vars_final, collapse=", "), "\n")
match_obj <- matchit(
formula = treatment_dummy ~ 1,
data = as.data.frame(data_for_matching),
method = "exact",
estimand = "ATT"
)
cat("  - Resumo do Pareamento Exato:\n")
print(summary(match_obj, un = FALSE))
matched_cpfs <- match.data(match_obj)$cpf
} else if (PSM_MODE == "psm_completo") {
# MODO 3: PAREAMENTO COMPLETO (EXATO + DISTÂNCIA)
cat("--- Executando o pareamento COMPLETO (Exato + Mahalanobis)...\n")
match_formula <- as.formula(paste("treatment_dummy ~", paste(nearest_vars_final, collapse = " + ")))
cat("  - Variáveis de pareamento exato:", paste(exact_vars_final, collapse=", "), "\n")
cat("  - Variáveis para distância:", paste(nearest_vars_final, collapse=", "), "\n")
match_obj <- matchit(
formula = match_formula,
data = as.data.frame(data_for_matching),
method = "nearest",
distance = "mahalanobis",
exact = exact_vars_final,
ratio = 1,
replace = FALSE,
estimand = "ATT"
)
cat("  - Resumo do Pareamento Completo:\n")
print(summary(match_obj, un = FALSE))
matched_cpfs <- match.data(match_obj)$cpf
} else {
stop("Modo de PSM '", PSM_MODE, "' não reconhecido. Verifique 00_config.R.")
}
PSM_MODE
# MODO 3: PAREAMENTO COMPLETO (EXATO + DISTÂNCIA)
cat("--- Executando o pareamento COMPLETO (Exato + Mahalanobis)...\n")
match_formula <- as.formula(paste("treatment_dummy ~", paste(nearest_vars_final, collapse = " + ")))
match_formula
cat("  - Variáveis de pareamento exato:", paste(exact_vars_final, collapse=", "), "\n")
cat("  - Variáveis para distância:", paste(nearest_vars_final, collapse=", "), "\n")
match_obj <- matchit(
formula = match_formula,
data = as.data.frame(data_for_matching),
method = "nearest",
distance = "mahalanobis",
exact = exact_vars_final,
ratio = 1,
replace = FALSE,
estimand = "ATT"
)
cat("  - Resumo do Pareamento Completo:\n")
print(summary(match_obj, un = FALSE))
match_obj
matched_cpfs <- match.data(match_obj)$cpf
matched_cpfs
summary(match_obj, un = FALSE)
# --- 4. Salvamento dos Resultados ---
cat("\nETAPA 4: Salvando os resultados...\n")
saveRDS(matched_cpfs, file = MATCHED_CPFS_PATH)
cat("  - Lista de", length(matched_cpfs), "CPFs para análise salva em:", MATCHED_CPFS_PATH, "\n")
cat("\n--- SCRIPT 03 CONCLUÍDO ---\n")
gc()
# --- 0. Limpeza, Pacotes e Configuração ---
rm(list = ls()); gc()
source("00_config.R")
library(data.table)
library(lubridate)
# --- 1. Carregamento dos Dados ---
cat("ETAPA 1: Carregando dados pós-pareamento para agregação...\n")
# Caminhos dos arquivos de entrada
FILTERED_DATA_INPUT_PATH <- file.path(OUTPUT_DIR, "02_filtered_data.rds")
MATCHED_CPFS_INPUT_PATH  <- file.path(OUTPUT_DIR, "03_matched_cpfs.rds")
# Caminho para o arquivo de saída deste script
FINAL_PANEL_OUTPUT_PATH <- file.path(OUTPUT_DIR, "04_final_analysis_panel.rds")
# Validação dos arquivos de entrada
if (!file.exists(FILTERED_DATA_INPUT_PATH)) stop("Arquivo de dados filtrados (02) não encontrado. Rode o script 02 primeiro.")
if (!file.exists(MATCHED_CPFS_INPUT_PATH)) stop("Arquivo de CPFs pareados (03) não encontrado. Rode o script 03 primeiro.")
# Carrega os dados
filtered_dt <- readRDS(FILTERED_DATA_INPUT_PATH)
matched_cpfs <- readRDS(MATCHED_CPFS_INPUT_PATH)
# =================================================================================
# ETAPA 2: PREPARAÇÃO E AGREGAÇÃO DO PAINEL
# =================================================================================
cat("ETAPA 2: Criando o painel de análise final...\n")
analysis_panel <- filtered_dt[cpf %in% matched_cpfs]
rm(filtered_dt, matched_cpfs); gc()
# --- ETAPA 2.2: Agregação para o Nível Indivíduo-Mês ---
cat("  - ETAPA 2.2: Agregando múltiplos vínculos para o nível Indivíduo-Mês...\n")
final_data <- analysis_panel[order(cpf, year, month, -salario_vinculo_mes_bruto), .(
# --- Características do Indivíduo/Vínculo Principal do Mês ---
uf = first(uf),
municipio = first(municipio),
assigned_group = first(assigned_group),
# --- Variáveis de Tempo e Referência do Indivíduo ---
data_referencia_mes = first(data_referencia_mes),
relative_time_month = first(relative_time_month),
num_empregos_cpf_mes = sum(!is.na(id_vinculo_original)),
# Hora média
hra_media = mean(horascontr, na.rm = TRUE),
sal_contr_medio = mean(salcontr, na.rm = TRUE),
sal_bruto_medio = mean(salario_vinculo_mes_bruto, na.rm = TRUE),
# --- AGREGAÇÃO DAS VARIÁVEIS DE RESULTADO (Y) ---
horascontr = sum(horas_ajustadas, na.rm = TRUE),
sal_contratual = sum(salcontr, na.rm = TRUE),
taxable_salary = sum(taxable_salary, na.rm = TRUE),
salario_total_cpf_mes = first(salario_total_cpf_mes),
paid_ir = max(paid_ir, na.rm = TRUE),
started_job = max(started_job, na.rm = TRUE),
left_job = max(left_job, na.rm = TRUE),
asked_to_leave = max(asked_to_leave, na.rm = TRUE),
retired_termination = max(retired_termination, na.rm = TRUE),
retired_without = max(retired_without, na.rm = TRUE),
changed_job = max(changed_job, na.rm = TRUE),
cbo_change_in_company = max(cbo_change_in_company, na.rm = TRUE),
cbo_change_at_start = max(cbo_change_at_start, na.rm = TRUE),
# cbo_to_2 = max(cbo_to_2, na.rm = TRUE),
# cbo_to_4 = max(cbo_to_4, na.rm = TRUE),
# cbo_not_3 = max(cbo_not_3, na.rm = TRUE),
# has_cbo_to_2 = first(has_cbo_to_2),
# has_cbo_to_4 = first(has_cbo_to_4),
# has_cbo_not_3 = first(has_cbo_not_3),
cumulative_unemployment = first(cumulative_unemployment),
#cumulative_unemployment_2 = first(cumulative_unemployment_2),
permanent_exit = first(permanent_exit),
var_contract = first(var_contract),
var_sal = first(var_sal),
var_sal_tot = first(var_sal_tot),
has_paid_ir = first(has_paid_ir),
has_started_job = first(has_started_job),
has_left_job = first(has_left_job),
has_asked_to_leave = first(has_asked_to_leave),
has_changed_job = first(has_changed_job),
has_cbo_change_at_start = first(has_cbo_change_at_start),
has_cbo_change_in_company = first(has_cbo_change_in_company),
has_retired_termination = first(has_retired_termination),
has_retired_without = first(has_retired_without),
has_paid_ir_consecutive = first(has_paid_ir_consecutive),
has_permanent_exit = first(has_permanent_exit)
), by = .(cpf, year, month)]
cat("  - Painel final criado com", format(nrow(final_data), big.mark="."), "observações únicas de CPF-Mês.\n")
cat("  - Amostra final contém", format(uniqueN(final_data$cpf), big.mark="."), "indivíduos únicos.\n")
rm(analysis_panel); gc()
# =====================================================================
# ETAPA 3: CÁLCULO DE VARIÁVEIS AGREGADAS E ACUMULADAS
# =====================================================================
cat("ETAPA 3: Calculando salário-hora e variáveis acumuladas...\n")
# 1. Calcular salário-hora usando as horas ajustadas.
final_data[, sal_hra := fifelse(horascontr > 0, salario_total_cpf_mes / horascontr, 0)]
final_data[, sal_cntr_hra_medio := fifelse(horascontr > 0, sal_contr_medio / hra_media, 0)]
final_data[, sal_bruto_hra_medio := fifelse(horascontr > 0, sal_bruto_medio / hra_media, 0)]
final_data[is.na(sal_bruto_medio), sal_bruto_medio := 0]
final_data[is.na(sal_contr_medio), sal_contr_medio := 0]
final_data[is.na(hra_media), hra_media := 0]
# 2. Criar variáveis acumuladas.
setorder(final_data, cpf, data_referencia_mes)
cat("  - Calculando somas acumuladas de forma robusta a NAs...\n")
final_data[, `:=` (
horas_acumuladas = cumsum(fifelse(is.na(horascontr), 0, horascontr)),
salario_acumulado = cumsum(fifelse(is.na(salario_total_cpf_mes), 0, salario_total_cpf_mes)),
sal_hra_acumulado = cumsum(fifelse(is.na(sal_hra), 0, sal_hra))
), by = .(cpf)]
cat("  - Variáveis 'sal_hra', 'horas_acumuladas', 'salario_acumulado' e 'sal_hra_acumulado' criadas.\n")
# =====================================================================
# ETAPA 4: SALVAMENTO DO PAINEL FINAL
# =====================================================================
cat("ETAPA 4: Salvando o painel de análise final...\n")
saveRDS(final_data, file = FINAL_PANEL_OUTPUT_PATH)
cat("\n--- SCRIPT 04 CONCLUÍDO ---\n")
cat("Painel final salvo com sucesso em:", FINAL_PANEL_OUTPUT_PATH, "\n")
gc()
View(final_data)
unique(final_data$cpf)
unique(final_data$cpf) %>% length()
length(final_data)
nrow(final_data)
unique(final_data$cpf) %>% length()
colnames(final_data)
